# список ребер графа (длина, вершина1, вершина2)
print("введите количество рёбер")
n=int(input())
R=[(0,0,0)]
for i in range (0,n):
    print("введите длину ребра, вершину1 и вершину2, соединённые ребром")
    M=(int(input()),int(input()),int(input()))
    R.append(M)
Rs = sorted(R, key=lambda x: x[0])
U = set()   # список соединенных вершин
D = {}      # словарь списка изолированных групп вершин
T = []      # список ребер остова
sum=0       # наименьшая длина
for r in Rs:
    if ((r[0]!=0) and (r[1] not in U or r[2] not in U)):  # проверка для исключения циклов в остове
        if r[1] not in U and r[2] not in U: # если обе вершины не соединены, то
            D[r[1]] = [r[1], r[2]]          # формируем в словаре ключ с номерами вершин
            D[r[2]] = D[r[1]]               # и связываем их с одним и тем же списком вершин
        else:                           # иначе
            if not D.get(r[1]):             # если в словаре нет первой вершины, то
                D[r[2]].append(r[1])        # добавляем в список первую вершину
                D[r[1]] = D[r[2]]           # и добавляем ключ с номером первой вершины
            else:                        #иначе
                D[r[1]].append(r[2])        # все то же самое делаем со второй вершиной
                D[r[2]] = D[r[1]]
        sum=sum+r[0]

        T.append(r)             # добавляем ребро в остов
        U.add(r[1])             # добавляем вершины в множество U
        U.add(r[2])

for r in Rs:    # проходим по ребрам второй раз и объединяем разрозненные группы вершин
    if (r[0]!=0) and (r[2] not in D[r[1]]):     # если вершины принадлежат разным группам, то объединяем
        T.append(r)             # добавляем ребро в остов
        sum=sum+r[0]
        gr1 = D[r[1]]
        D[r[1]] += D[r[2]]      # объединем списки двух групп вершин
        D[r[2]] += gr1

print("список длин и вершин",T,"наименьшая длина",sum)
